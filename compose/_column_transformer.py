import pandas as pd
import numpy as np

from sklearn.base import TransformerMixin, clone
from sklearn.utils.metaestimators import _BaseComposition

from ..preprocessing import Identity, ColumnSelector


__all__ = ['ColumnTransformer'] # 'make_column_transformer'




class ColumnTransformer(_BaseComposition, TransformerMixin):
    '''Applies transformers to columns of an array or pandas DataFrame.

    This estimator allows different columns or column subsets of the input
    to be transformed separately and the features generated by each transformer
    will be concatenated to form a single feature space. This is useful for
    combining several feature extraction mechanisms or transformations
    into a single transformer.

    Parameters
    ----------
    transformers : list
        List of (string, transformer, columns) tuples (implementing fit/transform).

    remainder : {'drop', 'pass'} or estimator, default 'drop'
        By default, only the specified columns in `transformers` are
        transformed and combined in the output, and the non-specified
        columns are dropped. (default of ``'drop'``).
        By specifying ``remainder='pass'``, all remaining columns that
        were not specified in `transformers` will be automatically passed
        through. This subset of columns is concatenated with the output of
        the transformers.
        By setting ``remainder`` to be an estimator, the remaining
        non-specified columns will use the ``remainder`` estimator. The
        estimator must support `fit` and `transform`.

    Attributes
    ----------
    transformers_ : list
        The collection of fitted transformers as tuples of (name, fitted_transformer,
        column). fitted_transformer can be an estimator, ‘drop’, or ‘pass’.
        In case there were no columns selected, this will be the unfitted transformer.
        If there are remaining columns, the final element is a tuple of the form:
        (‘remainder’, transformer, remaining_columns_) corresponding to the remainder
        parameter. If there are remaining columns, then
        len(transformers_)==len(transformers)+1, otherwise
        len(transformers_)==len(transformers).

    named_transformers_ : Bunch object, a dictionary with attribute access
        Access the fitted transformer by name.

    remaining_columns_ : list of strings
        List of remining columns.

    '''
    def __init__(self, transformers, remainder='drop'):
        self.transformers = transformers
        self.remainder = remainder


    @property
    def _transformers(self):
        """
        Internal list of transformer only containing the name and
        transformers, dropping the columns. This is for the implementation
        of get_params via BaseComposition._get_params which expects lists
        of tuples of len 2.
        """
        return [(name, trans) for name, trans, _ in self.transformers]


    def fit(self, X, y=None):
        """Fit all transformers using X.

        Parameters
        ----------
        X : DataFrame of shape [n_samples, n_features]
            Input data, of which specified subsets are used to fit the transformers.

        y : array-like, shape (n_samples, ...), optional
            Targets for supervised learning.

        Returns
        -------
        self : ColumnTransformer
            This estimator

        """
        self.transformers_ = []
        self.named_transformers_ = {}
        self.remaining_columns_ = set(X.columns)

        for name, transformer, cols in self.transformers:
            # Clone & fit
            fitted_transformer = clone(transformer).fit(X[cols], y)
            self.named_transformers_[name] = fitted_transformer
            # Access by key
            fitted_tuple = (name, fitted_transformer, cols)
            self.transformers_.append(fitted_tuple)
            # Remainin columns
            self.remaining_columns_ -= set(cols)

        self.remaining_columns_ = list(self.remaining_columns_)
        if self.remaining_columns_:

            name, cols = 'remainder', self.remaining_columns_

            if hasattr(self.remainder, 'fit') and hasattr(self.remainder, 'transform'):
                fitted_transformer = clone(self.remainder).fit(X[cols], y)

            elif self.remainder is 'pass':
                fitted_transformer = Identity().fit(X[cols], y)

            elif self.remainder is 'drop':
                fitted_transformer = ColumnSelector(cols=[]).fit(X[cols], y)

            else:
                raise ValueError('Unknown type for remainder. Must be "drop", "pass" or estimator.')

            fitted_tuple = (name, fitted_transformer, cols)
            self.transformers_.append(fitted_tuple)

        return self


    def transform(self, X):
        """Transform X separately by each transformer, concatenate results.

        Parameters
        ----------
        X : DataFrame of shape [n_samples, n_features]
            Input data, of which specified subsets are used to fit the transformers.

        Returns
        -------
        Xt : DataFrame, shape (n_samples, sum_n_components)
            hstack of results of transformers. sum_n_components is the
            sum of n_components (output dimension) over transformers.

        """
        Xt_list = []
        for name, transformer, cols in self.transformers_:
            Xt_list.append(transformer.transform(X[cols]))

        Xt = pd.concat(Xt_list, axis=1)
        return Xt


    def get_params(self, deep=True):
        """Get parameters for this estimator.

        Parameters
        ----------
        deep : boolean, optional
            If True, will return the parameters for this estimator and
            contained subobjects that are estimators.
        Returns
        -------
        params : mapping of string to any
            Parameter names mapped to their values.

        """
        return self._get_params('_transformers', deep=deep)


    def set_params(self, **kwargs):
        """Set the parameters of this estimator.

        Valid parameter keys can be listed with ``get_params()``.

        Returns
        -------
        self

        """
        self._set_params('_transformers', **kwargs)
        return self
