import pandas as pd
import numpy as np

from sklearn.base import BaseEstimator, TransformerMixin, clone

from ..preprocessing import Identity, ColumnSelector


__all__ = ['ColumnTransformer'] # 'make_column_transformer'




class ColumnTransformer(BaseEstimator, TransformerMixin):
    '''Applies transformers to columns of an array or pandas DataFrame.

    This estimator allows different columns or column subsets of the input
    to be transformed separately and the features generated by each transformer
    will be concatenated to form a single feature space. This is useful for
    combining several feature extraction mechanisms or transformations
    into a single transformer.

    Parameters
    ----------
    transformers : list
        List of (string, transformer, columns) tuples (implementing fit/transform).

    remainder : {'drop', 'pass'} or estimator, default 'drop'
        By default, only the specified columns in `transformers` are
        transformed and combined in the output, and the non-specified
        columns are dropped. (default of ``'drop'``).
        By specifying ``remainder='pass'``, all remaining columns that
        were not specified in `transformers` will be automatically passed
        through. This subset of columns is concatenated with the output of
        the transformers.
        By setting ``remainder`` to be an estimator, the remaining
        non-specified columns will use the ``remainder`` estimator. The
        estimator must support `fit` and `transform`.

    Attributes
    ----------
    transformers_ : list
        The collection of fitted transformers as tuples of (name, fitted_transformer,
        column). fitted_transformer can be an estimator, ‘drop’, or ‘pass’.
        In case there were no columns selected, this will be the unfitted transformer.
        If there are remaining columns, the final element is a tuple of the form:
        (‘remainder’, transformer, remaining_columns_) corresponding to the remainder
        parameter. If there are remaining columns, then
        len(transformers_)==len(transformers)+1, otherwise
        len(transformers_)==len(transformers).

    named_transformers_ : Bunch object, a dictionary with attribute access
        Access the fitted transformer by name.

    remaining_columns_ : list of strings
        List of remining columns.

    '''
    def __init__(self, transformers, remainder='drop'):
        self.transformers = transformers
        self.remainder = remainder


    def fit(self, X, y=None):
        """Fit all transformers using X.

        Parameters
        ----------
        X : DataFrame of shape [n_samples, n_features]
            Input data, of which specified subsets are used to fit the transformers.

        y : array-like, shape (n_samples, ...), optional
            Targets for supervised learning.

        Returns
        -------
        self : ColumnTransformer
            This estimator

        """
        self.transformers_ = []
        self.named_transformers_ = {}
        self.remaining_columns_ = set(X.columns)

        for name, transformer, cols in self.transformers:
            # Clone & fit
            fitted_transformer = clone(transformer).fit(X[cols], y)
            self.named_transformers_[name] = fitted_transformer
            # Access by key
            fitted_tuple = (name, fitted_transformer, cols)
            self.transformers_.append(fitted_tuple)
            # Remainin columns
            self.remaining_columns_ -= set(cols)

        self.remaining_columns_ = list(self.remaining_columns_)
        if self.remaining_columns_:

            name, cols = 'remainder', self.remaining_columns_

            if hasattr(self.remainder, 'fit') and hasattr(self.remainder, 'transform'):
                fitted_transformer = clone(self.remainder).fit(X[cols], y)

            elif self.remainder is 'pass':
                fitted_transformer = Identity().fit(X[cols], y)

            elif self.remainder is 'drop':
                fitted_transformer = ColumnSelector(cols=[]).fit(X[cols], y)

            else:
                raise ValueError('Unknown type for remainder. Must be "drop", "pass" or estimator.')

            fitted_tuple = (name, fitted_transformer, cols)
            self.transformers_.append(fitted_tuple)

        return self


    def transform(self, X):
        """Transform X separately by each transformer, concatenate results.

        Parameters
        ----------
        X : DataFrame of shape [n_samples, n_features]
            Input data, of which specified subsets are used to fit the transformers.

        Returns
        -------
        Xt : DataFrame, shape (n_samples, sum_n_components)
            hstack of results of transformers. sum_n_components is the
            sum of n_components (output dimension) over transformers.

        """
        Xt_list = []
        for name, transformer, cols in self.transformers_:
            Xt_list.append(transformer.transform(X[cols]))

        Xt = pd.concat(Xt_list, axis=1)
        return Xt
