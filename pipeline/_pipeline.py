import pandas as pd
import numpy as np

from sklearn.base import BaseEstimator, TransformerMixin, clone
from imblearn.pipeline import Pipeline, make_pipeline

from ..preprocessing import Identity, ColumnSelector




class FeatureUnion(BaseEstimator, TransformerMixin):
    '''Concatenates results of multiple transformer objects.

    This estimator applies a list of transformer objects in parallel to the
    input data, then concatenates the results. This is useful to combine
    several feature extraction mechanisms into a single transformer.

    Parameters of the transformers may be set using its name and the parameter
    name separated by a '__'. A transformer may be replaced entirely by
    setting the parameter with its name to another transformer,
    or removed by setting to 'drop' or ``None``.

    Parameters
    ----------
    transformers : list of (string, transformer) tuples
        List of transformer objects to be applied to the data. The first
        half of each tuple is the name of the transformer.

    Attributes
    ----------

    named_transformers_ : Bunch object, a dictionary with attribute access
        Access the fitted transformer by name.

    '''
    def __init__(self, transformers):
        self.transformers = transformers


    def fit(self, X, y=None):
        """Fit all transformers using X.

        Parameters
        ----------
        X : DataFrame of shape [n_samples, n_features]
            Input data, of which specified subsets are used to fit the transformers.

        y : array-like, shape (n_samples, ...), optional
            Targets for supervised learning.

        Returns
        -------
        self : FeatureUnion
            This estimator

        """
        self.named_transformers_ = {}

        for name, transformer in self.transformers:
            fitted_transformer = clone(transformer).fit(X, y)
            self.named_transformers_[name] = fitted_transformer

        return self


    def transform(self, X):
        """Transform X separately by each transformer, concatenate results.

        Parameters
        ----------
        X : DataFrame of shape [n_samples, n_features]
            Input data, of which specified subsets are used to fit the transformers.

        Returns
        -------
        Xt : DataFrame, shape (n_samples, sum_n_components)
            hstack of results of transformers. sum_n_components is the
            sum of n_components (output dimension) over transformers.

        """
        Xt_list = []
        for transformer in self.named_transformers_.values():
            Xt_list.append(transformer.transform(X))

        Xt = pd.concat(Xt_list, axis=1)
        return Xt


    def fit_transform(self, X, y=None):
        """Fit all transformers, transform the data and concatenate results.

        Parameters
        ----------
        X : DataFrame of shape [n_samples, n_features]
            Input data, of which specified subsets are used to fit the transformers.

        y : array-like, shape (n_samples, ...), optional
            Targets for supervised learning.

        Returns
        -------
        Xt : DataFrame, shape (n_samples, sum_n_components)
            hstack of results of transformers. sum_n_components is the
            sum of n_components (output dimension) over transformers.

        """
        return self.fit(X, y).transform(X)



class ColumnTransformer(BaseEstimator, TransformerMixin):
    '''Applies transformers to columns of an array or pandas DataFrame.

    This estimator allows different columns or column subsets of the input
    to be transformed separately and the features generated by each transformer
    will be concatenated to form a single feature space. This is useful for
    combining several feature extraction mechanisms or transformations
    into a single transformer.

    Parameters
    ----------
    transformers : list
        List of (string, transformer, columns) tuples (implementing fit/transform).

    remainder : {'drop', 'pass'} or estimator, default 'drop'
        By default, only the specified columns in `transformers` are
        transformed and combined in the output, and the non-specified
        columns are dropped. (default of ``'drop'``).
        By specifying ``remainder='pass'``, all remaining columns that
        were not specified in `transformers` will be automatically passed
        through. This subset of columns is concatenated with the output of
        the transformers.
        By setting ``remainder`` to be an estimator, the remaining
        non-specified columns will use the ``remainder`` estimator. The
        estimator must support `fit` and `transform`.

    Attributes
    ----------
    transformers_ : list
        The collection of fitted transformers as tuples of (name, fitted_transformer,
        column). fitted_transformer can be an estimator, ‘drop’, or ‘pass’.
        In case there were no columns selected, this will be the unfitted transformer.
        If there are remaining columns, the final element is a tuple of the form:
        (‘remainder’, transformer, remaining_columns_) corresponding to the remainder
        parameter. If there are remaining columns, then
        len(transformers_)==len(transformers)+1, otherwise
        len(transformers_)==len(transformers).

    named_transformers_ : Bunch object, a dictionary with attribute access
        Access the fitted transformer by name.

    remaining_columns_ : list of strings
        List of remining columns.

    '''
    def __init__(self, transformers, remainder='drop'):
        self.transformers = transformers
        self.remainder = remainder


    def fit(self, X, y=None):
        """Fit all transformers using X.

        Parameters
        ----------
        X : DataFrame of shape [n_samples, n_features]
            Input data, of which specified subsets are used to fit the transformers.

        y : array-like, shape (n_samples, ...), optional
            Targets for supervised learning.

        Returns
        -------
        self : ColumnTransformer
            This estimator

        """
        self.transformers_ = []
        self.named_transformers_ = {}
        self.remaining_columns_ = set(X.columns)

        for name, transformer, cols in self.transformers:
            # Clone & fit
            fitted_transformer = clone(transformer).fit(X[cols], y)
            self.named_transformers_[name] = fitted_transformer
            # Access by key
            fitted_tuple = (name, fitted_transformer, cols)
            self.transformers_.append(fitted_tuple)
            # Remainin columns
            self.remaining_columns_ -= set(cols)

        self.remaining_columns_ = list(self.remaining_columns_)
        if self.remaining_columns_:

            name, cols = 'remainder', self.remaining_columns_

            if hasattr(self.remainder, 'fit') and hasattr(self.remainder, 'transform'):
                fitted_transformer = clone(self.remainder).fit(X[cols], y)

            elif self.remainder is 'pass':
                fitted_transformer = Identity().fit(X[cols], y)

            elif self.remainder is 'drop':
                fitted_transformer = ColumnSelector(cols=[]).fit(X[cols], y)

            else:
                raise ValueError('Unknown type for remainder. Must be "drop", "pass" or estimator.')

            fitted_tuple = (name, fitted_transformer, cols)
            self.transformers_.append(fitted_tuple)

        return self


    def transform(self, X):
        """Transform X separately by each transformer, concatenate results.

        Parameters
        ----------
        X : DataFrame of shape [n_samples, n_features]
            Input data, of which specified subsets are used to fit the transformers.

        Returns
        -------
        Xt : DataFrame, shape (n_samples, sum_n_components)
            hstack of results of transformers. sum_n_components is the
            sum of n_components (output dimension) over transformers.

        """
        Xt_list = []
        for name, transformer, cols in self.transformers_:
            Xt_list.append(transformer.transform(X[cols]))

        Xt = pd.concat(Xt_list, axis=1)
        return Xt
